package com.johnsnowlabs.nlp.annotators.assertion.svm

import com.johnsnowlabs.nlp.{Annotation, AnnotatorType}
import com.johnsnowlabs.nlp.AnnotatorType._
import com.johnsnowlabs.nlp.annotators.assertion.logreg.mllib.vectors
import com.johnsnowlabs.nlp.annotators.assertion.logreg.{SimpleTokenizer, Tokenizer, Windowing}
import com.johnsnowlabs.nlp.embeddings.{ModelWithWordEmbeddings, WordEmbeddings}

import org.apache.spark.ml.param.Param
import org.apache.spark.ml.util.{DefaultParamsReadable, Identifiable}
import org.apache.spark.mllib.linalg.Vector
import org.apache.spark.sql._
import org.apache.spark.sql.expressions.UserDefinedFunction
import org.apache.spark.sql.functions._
import smile.classification.SVM

import scala.collection.immutable.Map


/**
  * Created by jose on 15/01/18.
  */
class AssertionSVMModel(override val uid: String = Identifiable.randomUID("ASSERTION")) extends ModelWithWordEmbeddings[AssertionSVMModel]
 with Windowing {


  val beforeParam = new Param[Int](this, "before", "Length of the context before the target")
  val afterParam = new Param[Int](this, "after", "Length of the context after the target")
  override lazy val (before, after) = (getOrDefault(beforeParam), getOrDefault(afterParam))
  def setBefore(before: Int) = set(beforeParam, before)
  def setAfter(after: Int) = set(afterParam, after)

  setDefault(
    beforeParam -> 11,
    afterParam -> 13
  )
  var labelMap: Option[Map[String, Double]] = None
  def setLabelMap(labelMappings: Map[String, Double]) = {
    labelMap = Some(labelMappings)
    this
  }

  /**
    * takes a document and annotations and produces new annotations of this annotator's annotation type
    *
    * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
    * @return any number of annotations processed for every input annotation. Not necessary one to one relationship
    */


  override protected def annotate(annotations: Seq[Annotation]): Seq[Annotation] = annotations

  override lazy val wordVectors: Option[WordEmbeddings] = embeddings

  /* so far we're using a SMILE model just to make development faster */
  var model : Option[SVM[Array[Double]]] = None
  def setModel(m: SVM[Array[Double]]): AssertionSVMModel = {
    model = Some(m)
    this
  }


  def setTagMap(m: Map[String, Array[Double]]): AssertionSVMModel = {
    tagMap = m
    this
  }


  var tagMap : Map[String, Array[Double]] = Map()


  override final def transform(dataset: Dataset[_]): DataFrame = {
    import dataset.sqlContext.implicits._
    require(validate(dataset.schema), s"Missing annotators in pipeline. Make sure the following are present: " +
      s"${requiredAnnotatorTypes.mkString(", ")}")

    /* apply UDF to fix the length of each document */
    val theUdf : UserDefinedFunction= applyWindowAndPOSUdf(vectors, tagMap)
    val processed = dataset.toDF.
      withColumn("features", theUdf($"text", $"target", $"start", $"end", $"pos"))

    val labelCol = "label" // getOrDefault(labelColumn)

    //not necessary here
    val processedWithLabel = processed.withColumn(labelCol, labelToNumber(labelMap.get)(col(labelCol)))
    require(model.isDefined, "model must be set before tagging")

    val theUDF = udf {
      features: Vector =>
        model.get.predict(features.toArray)
    }

    processedWithLabel.withColumn(getOutputCol, theUDF(col("features")))

    /*


        /* apply UDF to fix the length of each document */
        val theUdf = applyWindowUdf(vectors)
        val processed = dataset.toDF.
          withColumn("features", theUdf ($"text", $"target", $"start", $"end"))

        model.get.transform(processed).withColumn(getOutputCol, packAnnotations($"text", $"target", $"start", $"end", $"prediction"))
    */
  }

  private def numberToLabel(mappings: Map[Double, String]) = udf { label:Double  => mappings.get(label)}
  private def doubleToInt() = udf { label:Double  => label.toInt}
  override val requiredAnnotatorTypes: Array[String] = Array(DOCUMENT, POS)
  override val annotatorType: AnnotatorType = AnnotatorType.ASSERTION
  override val tokenizer: Tokenizer = new SimpleTokenizer
  private def labelToNumber(mappings: Map[String, Double]) = udf { label:String  => mappings.get(label)}
}

object AssertionSVMModel extends DefaultParamsReadable[AssertionSVMModel] {
  def apply(): AssertionSVMModel = new AssertionSVMModel()
}